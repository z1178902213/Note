在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。

你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。

**示例1:**

> **输入: [1,4], 2**  
> **输出: 4**  
> **原因:** 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。
> 第 4 秒初，提莫再次攻击艾希，使得艾希获得另外 2 秒中毒时间。  
> 所以最终输出 4 秒。

**示例2:**

> **输入:** [1,2], 2  
> **输出:** 3  
> **原因:** 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。  
> 但是第 2 秒初，提莫再次攻击了已经处于中毒状态的艾希。  
> 由于中毒状态不可叠加，提莫在第 2 秒初的这次攻击会在第 3 秒末结束。  
> 所以最终输出 3 。

**提示：**

1. 你可以假定时间序列数组的总长度不超过 10000。
2. 你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过 10,000,000。

# 自己的解法

判断数组中相邻的两个时间点的时间差，对于不同的时间差有不同的操作：

1. 当时间差小于等于duration，则认为中毒时间重合，总的中毒时长只要加上时间差即可。
2. 当时间差大于duration，则认为两次中毒时间间隔足够久，前一次中毒没有被覆盖，是完整的一个duration的时间，则中毒时间加上duration。
3. 当查找到时间序列最后一个时间点，则默认认为中了一次完整的毒，中毒时间加一个duration。为了防止所给的是一个空序列，需要对序列进行判断。

代码如下：

```java
class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        if(timeSeries.length == 0){ //若传入的时间序列是空序列，直接返回0
            return 0;
        }
        int poisoningTime = 0;  //艾希总中毒时间
        for(int i = 0; i < timeSeries.length - 1; i++){
            if(timeSeries[i+1] - timeSeries[i] <= duration){
                poisoningTime += timeSeries[i+1] - timeSeries[i];
            }else{
                poisoningTime += duration;
            }
        }
        poisoningTime += duration;
        return poisoningTime;
    }
}
```

时间复杂度O(n)，空间复杂度O(1)

# 官方解法

##### 1. 单次扫描

和我的方法一样，官方方法用了一个Math.min的方法，不用像我那个用if else判断。