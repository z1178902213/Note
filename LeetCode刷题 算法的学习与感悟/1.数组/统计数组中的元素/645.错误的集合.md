**集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。**

**给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。**

**示例 1:**

> 输入: nums = [1,2,2,4]  
> 输出: [2,3]  

**注意:**

* 给定数组的长度范围是 [2, 10000]。
* 给定的数组是无序的。

# 自己的解法

由于这个数组是包含了从[0, n-1]中的所有数，因此，仅一个数出现了两次，仅一个数从未出现，并且这些数在0到n-1之内，可以用一个n维数组将出现的数字记录下来，最后遍历一遍数组就知道哪个数字从未出现过。

代码详情：

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int tmp[] = new int[nums.length];
        int result[] = new int[2];
        for(int i = 0; i < nums.length; i++){
            tmp[nums[i] - 1] ++;
        }
        for(int i = 0; i < nums.length; i++){
            if(tmp[i] == 0){
                result[1] = i+1;
            }
            if(tmp[i] == 2){
                result[0] = i+1;
            }
        }
        return result;
    }
}
```

时间复杂度O(n)，空间复杂度O(n)。

# 官方解法

1. 暴力解法：遍历n次数组，分别用1、2、3.....n与其进行对比。
2. 排序：先进行一次排序，最后并列的相等的数就是重复的数，从而得出答案。
3. 额外数组法：就是自己的解法。
4. 用map：可以用map记录数组中每个元素的出现次数，最后遍历一遍map，没有出现过和出现过两次的元素就是要找的元素。
5. **★元素反转：**由于已知数组元素为从1到n正数，因此，为第i个nums[i]的元素取相反数。若在取相反数之前发现nums[i]中的元素已经是负数，则说明就是i这个数重复了。最后在遍历数组，为正数的元素的下标+1就是缺失数字。（这种方法不是对数组直接遍历来找出所需元素，而是通过循环中的1-n来进行判断，是一种非常巧妙的技巧！）
6. **★异或运算**：看不懂。

